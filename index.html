<!DOCTYPE html>
<html>
<head>
  <script src="includes/config.js"></script>
  <link rel="stylesheet" href="includes/styles.css" />
  <script src="includes/color.js"></script>
  <script src="includes/formatters.js"></script>
  <script src="includes/downtime.js"></script>
  <script src="includes/weather.js"></script>
  
  <link id="dynamic-favicon" rel="icon" type="image/svg+xml">
  <script src="includes/favicon.js" defer></script>

<script>
  document.title = "Jetstream: " + CONFIG.city_name;

  document.addEventListener("DOMContentLoaded", () => {
    // Update the title div
    const locationDiv = document.getElementById("title");
    locationDiv.innerHTML = `Jetstream: ${CONFIG.city_name} <span class="version">v5.0</span>`;

    // Attach refresh button handler after DOM is fully loaded
    const refreshBtn = document.getElementById('refresh-page-btn');
    if (refreshBtn) {
      refreshBtn.addEventListener('click', () => {
        location.reload();
      });
    }
  });

    // Auto-refresh every 30 minutes
  setInterval(() => {
    location.reload();
  }, 1800000);
</script>

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet">
  
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@drustack/leaflet.resetview/dist/L.Control.ResetView.min.js"></script>
  

 </head>


<body>
  <button id="refresh-page-btn" title="Refresh the page">&#8634;</button>
    <div id="main"> 
      <div id="map"></div>
      <div id="title"></div>
      <div id="info"></div>
      <div id="flight-counter">Total flights today: </div>
  </div>

  <script>

    const map = L.map('map', {
      zoomControl: false,
      dragging: true,
      scrollWheelZoom: false,
      doubleClickZoom: false,
      boxZoom: false,
      keyboard: false,
      touchZoom: false,
      attributionControl: false
    }).setView([CONFIG.center_lat, CONFIG.center_lon], CONFIG.initialZoom); // Use CONFIG constants

    L.tileLayer('http://services.arcgisonline.com/arcgis/rest/services/Canvas/World_Dark_Gray_Base/MapServer/tile/{z}/{y}/{x}', {
      maxZoom: CONFIG.maxZoom,
    }).addTo(map);

    L.control.resetView({
                position: "topleft",
                title: "Reset view",
                latlng: L.latLng([CONFIG.center_lat, CONFIG.center_lon]),
                zoom: CONFIG.initialZoom,
            }).addTo(map);

      // Add a custom SVG icon for the house marker
  const houseIcon = L.divIcon({
    html: `<div style="width:24px;height:24px;display:flex;align-items:center;justify-content:center;">
      <svg width="18" height="18" viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg">
        <circle cx="9" cy="9" r="7" fill="#000" stroke="#000" stroke-width="2" />
      </svg>
    </div>`,
    className: 'house-icon',
    iconSize: [24, 24],
    iconAnchor: [12, 12]
  });

  if(CONFIG.use_night_bbox){
    const now = new Date();
    const currentHour = now.getHours();
    const is_night = CONFIG.night_begin_hour < CONFIG.night_end_hour
      ? currentHour >= CONFIG.night_begin_hour && currentHour < CONFIG.night_end_hour
      : currentHour >= CONFIG.night_begin_hour || currentHour < CONFIG.night_end_hour;
      if (is_night) {
      // Use night bounding box if configured and during downtime
      CONFIG.south_edge = CONFIG.night_south_edge;
      CONFIG.north_edge = CONFIG.night_north_edge;
      CONFIG.west_edge = CONFIG.night_west_edge;
      CONFIG.east_edge = CONFIG.night_east_edge;
      console.log("Using night bounding box.");
    }
  }

  const houseMarker = L.marker([CONFIG.center_lat, CONFIG.center_lon], { icon: houseIcon })
    .addTo(map)
    .bindPopup("Home");

  if (CONFIG.use_bbox && CONFIG.show_bbox) {
    const bounds = [
      [CONFIG.south_edge, CONFIG.west_edge], // Southwest corner
      [CONFIG.north_edge, CONFIG.east_edge]  // Northeast corner
    ];

    L.rectangle(bounds, {
      color: "#616163",      // Border color
      weight: 2,             // Border thickness
      opacity: 0.6,          // Border opacity
      fill: false,            // Whether to fill the box
    }).addTo(map);
  }

    function format_name(location) {
      if (!location) return '';
      const city = location.city;
      const country = location.country;
      if (city && city !== 'N/A') {
      return country ? `${city}, ${country}` : city;
      }
      return country || '';
    }

    let categoryLookup = {};
    let typeLookup = {};

    // Load category_lookup.json
    fetch('includes/category_lookup.json')
      .then(response => response.json())
      .then(data => {
        categoryLookup = data;
      })
      .catch(err => {
        console.error('Error loading category_lookup.json:', err);
      });

    // Load type_lookup.json
    fetch('includes/type_lookup.json')
      .then(response => response.json())
      .then(data => {
        typeLookup = data;
      })
      .catch(err => {
        console.error('Error loading type_lookup.json:', err);
      });

    function select_marker(type, category){
      // Normalize keys to match lookup object keys (e.g., uppercase and trimmed)
      const normType = type ? String(type).trim().toUpperCase() : null;
      const normCategory = category ? String(category).trim().toUpperCase() : null;
      if (normType && typeLookup[normType]) {
        return typeLookup[normType];
      } else if (normCategory && categoryLookup[normCategory]) {
        return categoryLookup[normCategory];
      }
      return 'icons/airliner.svg';
    }

    let planeMarkers = {};
    // Track unique flights for the day

    async function fetchPlanes() {
      // Remove previous circle if exists (always, even on error)
      if (window.closestPlaneCircle) {
        map.removeLayer(window.closestPlaneCircle);
        window.closestPlaneCircle = null;
      }

      // Always remove old markers before fetching new data
      for (let id in planeMarkers) {
        map.removeLayer(planeMarkers[id]);
      }
      planeMarkers = {};

      const bounds = map.getBounds();
      //const getPlanes = `http://localhost:3000/planes?lat=${CONFIG.lat}&lon=${CONFIG.lon}&dist=${CONFIG.distance}`;
      const getPlanes = `http://localhost:3000/planes2?lat=${CONFIG.lat}&lon=${CONFIG.lon}&dist=${CONFIG.distance}&use_bbox=${CONFIG.use_bbox}&minLat=${CONFIG.south_edge}&maxLat=${CONFIG.north_edge}&minLon=${CONFIG.west_edge}&maxLon=${CONFIG.east_edge}`;

      try {
        console.log("Fetching planes...");
        const res = await fetch(getPlanes);
        const data = await res.json();
        console.log(data);

        // Remove old markers
        for (let id in planeMarkers) {
          map.removeLayer(planeMarkers[id]);
        }
        planeMarkers = {};

        let closestPlane = null;
        let closestDistance = Infinity;
        let closestMarker = null;
        let closestOrigin = 'N/A';
        let closestDestination = 'N/A';

        // Check if no aircraft data or empty array
        if (!data.ac || data.ac.length === 0) {
          const weatherHTML = await displayWeatherWidget();
          document.getElementById('info').innerHTML = weatherHTML;
          return;
        }

        for (let plane of data.ac) {
          if (plane.flight) {
            fetch('http://localhost:3000/log-flight', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ flightId: plane.flight })
            })
            .then(response => response.json())
            .then(data => {
              if (!data.success) {
                console.error('Flight logging failed:', data.error);
              }
            })
            .catch(err => {
              console.error('Error logging flight:', err);
            });
          }
          if (plane.lat && plane.lon) {
          // Calculate distance to center
          const dLat = (plane.lat - CONFIG.center_lat);
          const dLon = (plane.lon - CONFIG.center_lon);
          const distance = Math.sqrt(dLat * dLat + dLon * dLon);

          if (distance < closestDistance) {
            closestDistance = distance;
            closestPlane = plane;
          }
          }
        }

        for (let plane of data.ac) {
          if (plane.lat && plane.lon) {
          
          const opacity = plane.alt_baro ? Math.max(0.3, Math.min(1, plane.alt_baro / 1000)) : 1;
          selected_marker = select_marker(plane.t, plane.category)
          const icon = L.divIcon({
          html: `<div style="display: flex; justify-content: center; align-items: center; width: 60px; height: 60px;">
            <div style="
              width: 48px;
              height: 48px;
              background-color: ${CONFIG.highlight_color};
              mask: url(${selected_marker}) center/contain no-repeat;
              -webkit-mask: url(${selected_marker}) center/contain no-repeat;
              transform: rotate(${(plane.track || 0)}deg);
              "></div>
          </div>`,

          
            className: 'plane-icon',
            iconSize: [60, 60],
            iconAnchor: [30, 30]
          });

          // Fetch additional flight info
          let origin = 'N/A';
          let destination = 'N/A';
          let flight_name = '';
          let hasRoute = false;

          if (plane.flight) {
            try {
              // Fetch aircraft info
              console.log(`Fetching aircraft info for ${plane.flight}`);
              const aircraft_info_res = await fetch(`http://localhost:3000/aircraft?callsign=${plane.flight}&reg=${plane.r}`);
              const aircraft_info = await aircraft_info_res.json();
              console.log(`Aircraft info for ${plane.flight}:`, aircraft_info);
              flight_name = aircraft_info?.response?.aircraft?.registered_owner.toUpperCase() || '';
              origin = '';
              destination = '';
              aircraft_url = aircraft_info?.response?.aircraft?.url_photo_thumbnail || '';
              aircraft_mfg = aircraft_info?.response?.aircraft?.manufacturer || '';
              aircraft_type = aircraft_info?.response?.aircraft?.type || '';
              route_is_valid = false;

              // Fetch flight info if aircraft info is available
              if(aircraft_info.response.aircraft) {
                console.log(`Fetching flight info for ${plane.flight}`);
                const flightInfoRes = await fetch(`http://localhost:3000/flightinfo?callsign=${plane.flight}&heading=${plane.track}&current_lat=${plane.lat}&current_lon=${plane.lon}`);
                const flightInfoData = await flightInfoRes.json();
                console.log(`Flight info for ${plane.flight}:`, flightInfoData);

                // Extract origin and destination from flight info
                if (flightInfoData && flightInfoData.callsign) {
                  route_is_valid = flightInfoData?.valid || false; // Use the valid field from flight info
                  origin = flightInfoData?.origin || '';
                  console.log(`Origin info for ${plane.flight}:, ${JSON.stringify(origin)}`);
                  destination = flightInfoData?.destination || '';
                  console.log(`Dest info for ${plane.flight}:, ${JSON.stringify(destination)}`);
                  flight_name = flight_name || flightInfoData?.airline_name.toUpperCase() ||  '';
                  hasRoute = true;
                }
              }
            } catch(err) {
              console.error(`Error fetching route info for ${plane.flight}:`, err);
            }
          }

          const marker = L.marker([plane.lat, plane.lon], { icon: icon })
            .bindPopup(`
            <div>
              <strong>Flight ${plane.flight || 'N/A'}</strong><br>
              <strong>${flight_name}</strong><br><br>

              ${format_name(origin) !== '' ? `Origin: ${format_name(origin)}<br><small>${clean_field(origin.name)}</small><br><br>` : ''}
              ${format_name(destination) !== '' ? `Destination: ${format_name(destination)}<br><small>${clean_field(destination.name)}</small><br><br>` : ''}
              ${aircraft_url !== '' ? `<img src="${aircraft_url}" alt="Aircraft Photo" style="max-width: 100%; height: auto;"><br>`
  : ''}
              <strong>Altitude:</strong> ${plane.alt_baro || ''}<br>
              <strong>Speed:</strong> ${plane.gs ? `${plane.gs} knots` : 'N/A'}<br>
              ${aircraft_mfg !== '' ? `<strong>Aircraft:</strong> ${aircraft_mfg} ${aircraft_type}<br>` : ''}
              <br>
              View on <a href="https://www.flightradar24.com/${plane.flight}" target="_blank"> FlightRadar24</a> | 
               <a href="https://www.flightaware.com/live/flight/${plane.flight}" target="_blank">FlightAware</a>
            </div>
            `)
            .addTo(map);

          planeMarkers[plane.hex] = marker;
          

          // Save marker and info for closest plane
          if (closestPlane && plane.hex === closestPlane.hex) {
            closestMarker = marker;
            closestOrigin = origin;
            closestDestination = destination;
            closestOriginName = format_name(closestOrigin)
            closestDestinationName = format_name(closestDestination)
            closestFlightName = flight_name;
            closestAircraft = aircraft_mfg + ' ' + aircraft_type;
            closestRoute_is_valid = route_is_valid;
          }
          }
        }

        // Highlight closest plane
        // Remove previous circle if exists
        if (window.closestPlaneCircle) {
          map.removeLayer(window.closestPlaneCircle);
        }
        if (closestPlane && closestMarker) {
          window.closestPlaneCircle = L.circle([closestPlane.lat, closestPlane.lon], {
          radius: 800, // meters
          color: CONFIG.highlight_color,
          fill: false, // No fill at all
          weight: 1 // Optional: makes the circle outline a bit more visible
          }).addTo(map);

          // Update info div
          document.getElementById('info').innerHTML = `
          
          <div id='sidebar-info'">
            <h2>
              <a href="https://www.flightaware.com/live/flight/${closestPlane.flight}" target="_blank">
                ${closestPlane.flight || 'N/A'}
              </a>
              <!-- ${closestOrigin && !closestRoute_is_valid ? '<sup class="invalid-route-flag">!</sup>' : ''} -->
            </h2>
            <p>${closestFlightName || ''}</p>
            <div class="sb-route">
              <h1>Origin</h1>
              <h2>${closestOriginName}</h1>
              <h3>${closestOrigin['name'] || ''}<h3>
            </div>
            <div class="sb-route">
              <h1>Destination</h2>
              <h2>${closestDestinationName}</h1>
              <h3>${closestDestination['name'] || ''}<h3>
            </div>
            <div class="sb-flight-info">
              <strong> ${closestAircraft || closestPlane.t || ''}</strong><br>
              <strong>Altitude:</strong> ${closestPlane.alt_baro || ''} ft<br>
              <strong>Speed:</strong> ${closestPlane.gs ? `${closestPlane.gs} knots` : ''}<br><br>
              <a href="https://www.flightaware.com/live/flight/${closestPlane.flight}" target="_blank">View on FlightAware</a>
            </div>
          </div>
          `;
        } else {
          // No planes found, show weather widget
          const weatherHTML = await displayWeatherWidget();
          document.getElementById('info').innerHTML = weatherHTML;
        }
      } catch (err) {
        console.error('Error fetching aircraft:', err);
        // Error fetching planes, show weather widget
        const weatherHTML = await displayWeatherWidget();
        document.getElementById('info').innerHTML = weatherHTML;
      }
    }

    // Fetch planes at the configured refresh rate
    fetchPlanes();
    
    function getCurrentRefreshRate() {
      // During downtime when awake, use normal refresh rate
      if (CONFIG.use_downtime && typeof downtimeState !== 'undefined' && downtimeState.isAwake) {
        return CONFIG.refreshRate;
      }
      return CONFIG.refreshRate;
    }

    let refreshInterval = setInterval(fetchPlanes, getCurrentRefreshRate());

    // Fetch and display today's flight count
async function updateFlightCounter() {
  try {
    const res = await fetch('http://localhost:3000/flight-count');
    const data = await res.json();
    document.getElementById('flight-counter').textContent = `Total flights today: ${data.count}`;
  } catch (err) {
    document.getElementById('flight-counter').textContent = 'Total flights today: N/A';
    console.error('Error fetching flight count:', err);
  }
}

// Call once on load and every 60 seconds
updateFlightCounter();
setInterval(updateFlightCounter, 60000);

  </script>
  
</body>
</html>